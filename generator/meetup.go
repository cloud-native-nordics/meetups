package main

import (
	"encoding/json"
	"fmt"
	"math"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"
)

// GetMeetupInfoFromAPI fetches all information it can about the given meetup group
// from the meetup.com API, and returns the autogenerated type
func GetMeetupInfoFromAPI(humanGen MeetupGroup) (*AutogenMeetupGroup, error) {
	mg := &meetupGroupAPI{
		Meetups: []meetupAPI{},
	}
	if err := fetchMeetupGroup(humanGen.MeetupID, mg); err != nil {
		return nil, err
	}
	if err := fetchMeetups(humanGen.MeetupID, &mg.Meetups); err != nil {
		return nil, err
	}
	result := &AutogenMeetupGroup{
		AutoMeetups: map[string]AutogenMeetup{},
	}
	result.members = mg.Members
	result.Description = mg.Description
	result.Photo = mg.Photo.Link
	result.Country = strings.ToLower(mg.Country)
	result.City = mg.City
	if newName, ok := cityNameExceptions[mg.City]; ok {
		result.City = newName
	}
	result.Name = mg.Name

	for _, ev := range mg.Meetups {
		t, err := ev.GetTime()
		if err != nil {
			return nil, err
		}
		dateStr := t.YYYYMMDD()
		for _, ignoreDate := range humanGen.IgnoreMeetupDates {
			if ignoreDate == dateStr {
				continue
			}
		}
		meetup := AutogenMeetup{}
		id, _ := strconv.Atoi(ev.ID)
		meetup.ID = uint64(id)
		meetup.Photo = ev.Photo.Link
		meetup.Date = *t
		meetup.Name = ev.Name
		meetup.Address = ev.Venue.Address
		meetup.Duration = Duration{time.Duration(ev.Duration * 1000 * 1000)}

		if time.Now().UTC().After(meetup.Date.Time) {
			meetup.Attendees = ev.RVSPs
			// Only collect RSVP data after the event
			ev.Attendance = []meetupAttendanceAPI{}
			if err := fetchAttendanceList(humanGen.MeetupID, meetup.ID, &ev.Attendance); err != nil {
				return nil, err
			}
			meetup.rsvps = attendanceToRSVPList(ev.Attendance)
		} else {
			meetup.Attendees = 0
		}

		result.AutoMeetups[t.YYYYMMDD()] = meetup
	}
	return result, nil
}

func fetchMeetupGroup(meetupGroupID string, mg *meetupGroupAPI) error {
	url := fmt.Sprintf("https://api.meetup.com/%s", meetupGroupID)
	return GetJSON(url, mg)
}

func fetchMeetups(meetupGroupID string, meetups *[]meetupAPI) error {
	url := fmt.Sprintf("https://api.meetup.com/%s/events?sign=true&photo-host=public&page=100&status=past,upcoming&fields=featured_photo", meetupGroupID)
	return GetJSON(url, meetups)
}

func fetchAttendanceList(meetupGroupID string, meetupID uint64, att *[]meetupAttendanceAPI) error {
	url := fmt.Sprintf("https://api.meetup.com/%s/events/%d/attendance?&sign=true&photo-host=public&page=20", meetupGroupID, meetupID)
	return GetJSON(url, att)
}

type meetupGroupAPI struct {
	ID          uint64 `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	City        string `json:"untranslated_city"`
	Country     string `json:"localized_country_name"`
	Members     uint64 `json:"members"`
	Photo       struct {
		Link string `json:"highres_link"`
	} `json:"key_photo"`
	Meetups []meetupAPI `json:"-"`
}

type meetupAPI struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Duration int64  `json:"duration"`
	Date     string `json:"local_date"`
	Time     string `json:"local_time"`
	RVSPs    uint64 `json:"yes_rsvp_count"`
	Venue    struct {
		Address string `json:"address_1"`
	} `json:"venue"`
	Photo struct {
		Link string `json:"highres_link"`
	} `json:"featured_photo"`
	Attendance []meetupAttendanceAPI `json:"-"`
}

func (ev *meetupAPI) GetTime() (*Time, error) {
	dateTime := fmt.Sprintf("%sT%s:00Z", ev.Date, ev.Time)
	d, err := time.Parse(time.RFC3339, dateTime)
	if err != nil {
		return nil, err
	}
	return &Time{d}, nil
}

type meetupAttendanceAPI struct {
	Member struct {
		ID   uint64 `json:"id"`
		Name string `json:"name"`
	} `json:"member"`
	RSVP struct {
		Response string `json:"response"`
		Guests   uint64 `json:"guests"`
	} `json:"rsvp"`
}

// attendanceToRSVPList converts the data from the meetup.com API format to a map
// of meetup user ID and amount of unique RSVPs for that user (the user itself is
// counted once, and all guests are summed up)
func attendanceToRSVPList(attendance []meetupAttendanceAPI) map[uint64]uint64 {
	// rsvpMap maps an user ID to the amount of RSVPs for that user
	rsvpMap := map[uint64]uint64{}
	for _, attendee := range attendance {
		// don't count any other rsvp's than yes
		if attendee.RSVP.Response != "yes" {
			continue
		}
		// In the unlikely event that the same user ID would occur twice, we don't
		// double-count that user. All guests are summed up however.
		rsvps, ok := rsvpMap[attendee.Member.ID]
		if ok {
			rsvpMap[attendee.Member.ID] = rsvps + attendee.RSVP.Guests
		} else {
			rsvpMap[attendee.Member.ID] = 1 + attendee.RSVP.Guests
		}
	}
	return rsvpMap
}

func GetJSON(url string, v interface{}) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(v); err != nil {
		return fmt.Errorf("GetJSON failed for url %s with error %v", url, err)
	}
	return nil
}

func setPresentationTimestamps(m *Meetup) error {
	for i := range m.Presentations {
		p := &m.Presentations[i]
		var t time.Time
		if i == 0 {
			t = m.Date.Time
		} else {
			p2 := m.Presentations[i-1]
			t = p2.end
		}
		if p.Delay != nil {
			t = t.Add((*p.Delay).Duration)
		}
		p.start = t
		p.end = p.start.Add(p.Duration.Duration)
	}
	return nil
}

func aggregateStats(cfg *Config) (*StatsFile, error) {
	s := &StatsFile{
		MeetupGroups: uint64(len(cfg.MeetupGroups)),
		PerMeetup:    map[string]MeetupStats{},
	}

	var wg sync.WaitGroup
	wg.Add(len(cfg.MeetupGroups))
	mux := &sync.Mutex{}

	for _, mg := range cfg.MeetupGroups {
		go func(mg MeetupGroup) {
			defer wg.Done()

			mgStat := MeetupStats{
				SponsorByTier: map[SponsorTier]uint64{},
			}
			mgStat.Members = mg.members
			totalRSVPs := uint64(0)
			// uniqueRSVPs maps an user ID to the amount of RSVPs for that user
			uniqueRSVPs := map[uint64]uint64{}
			speakers := map[string]bool{}
			priorMeetups := uint64(0)
			for _, m := range mg.Meetups {
				if m.Date.UTC().After(time.Now().UTC()) {
					continue
				}
				priorMeetups++
				totalRSVPs += m.Attendees
				for _, pres := range m.Presentations {
					for _, s := range pres.Speakers {
						speakers[string(s.ID)] = true
					}
				}

				if m.rsvps != nil {
					for userID, rsvpAmount := range m.rsvps {
						rsvps, ok := uniqueRSVPs[userID]
						if ok {
							// add the cumulatively the amount of guests (excluding the user, as they have already been counted)
							uniqueRSVPs[userID] = rsvps + rsvpAmount - 1
						} else {
							// the first time, count the user itself, too
							uniqueRSVPs[userID] = rsvpAmount
						}
					}
				}
			}

			var sponsors uint64 = 0
			for _, tier := range mg.SponsorTiers {
				mgStat.SponsorByTier[tier] += 1
				if tier != SponsorTierEcosystemMember {
					sponsors++
				}
			}

			mgStat.Sponsors = sponsors
			mgStat.Speakers = uint64(len(speakers))
			mgStat.TotalRSVPs = totalRSVPs
			if priorMeetups > 0 {
				mgStat.Meetups = priorMeetups
				mgStat.AverageRSVPs = uint64(math.Floor(float64(totalRSVPs / priorMeetups)))
			}
			for _, num := range uniqueRSVPs {
				mgStat.UniqueRSVPs += num
			}

			// Write to the global state one goroutine at a time
			mux.Lock()
			defer mux.Unlock()

			s.PerMeetup[mg.CityLowercase()] = mgStat

			s.AllMeetups.Meetups += mgStat.Meetups
			s.AllMeetups.Members += mgStat.Members
			s.AllMeetups.TotalRSVPs += mgStat.TotalRSVPs
			s.AllMeetups.UniqueRSVPs += mgStat.UniqueRSVPs
			s.AllMeetups.Speakers += mgStat.Speakers
			s.AllMeetups.Sponsors += mgStat.Sponsors
		}(mg)
	}
	wg.Wait()
	s.AllMeetups.AverageRSVPs = uint64(math.Floor(float64(s.AllMeetups.TotalRSVPs / s.AllMeetups.Meetups)))
	return s, nil
}
